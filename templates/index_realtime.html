<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-Time Emotion Analysis</title>
    <!-- Include Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
        line-height: 1.6;
      }
      .container {
        max-width: 800px;
        margin: auto;
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 8px;
        background-color: #f9f9f9;
      }
      .controls,
      .status,
      .results,
      .report,
      .session-management {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #eee;
        background-color: #fff;
        border-radius: 5px;
      }
      h2 {
        margin-top: 0;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
      }
      button {
        padding: 10px 15px;
        margin-right: 10px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        color: white;
      }
      #startBtn {
        background-color: #28a745;
      }
      #stopBtn {
        background-color: #dc3545;
      }
      #startBtn:disabled,
      #stopBtn:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      #statusText {
        font-weight: bold;
      }
      #dominantEmotion {
        font-size: 1.2em;
        font-weight: bold;
        margin-top: 10px;
        color: #007bff;
      }
      .chart-container {
        position: relative;
        height: 300px;
        width: 100%;
      }
      pre {
        background-color: #e9ecef;
        padding: 10px;
        border-radius: 4px;
        font-size: 0.9em;
        max-height: 200px;
        overflow-y: auto;
      }
      a {
        color: #007bff;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      /* Optional: Style for video feed display */
      #videoFeed {
        display: block;
        margin-top: 15px;
        max-width: 100%;
        border: 1px solid #ddd;
      }

      /* New styles for session management */
      .session-management {
        background-color: #f8f9fa;
      }
      .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 15px;
      }
      .sessions-list {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        background-color: #fff;
      }
      .session-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        border-bottom: 1px solid #eee;
      }
      .session-item:last-child {
        border-bottom: none;
      }
      .session-info {
        flex: 1;
      }
      .session-name {
        font-weight: bold;
        display: block;
      }
      .session-meta {
        font-size: 0.8em;
        color: #666;
      }
      .load-session-btn {
        background-color: #6c757d;
        color: white;
        padding: 5px 10px;
        border-radius: 3px;
        cursor: pointer;
      }
      .load-session-btn:hover {
        background-color: #5a6268;
      }

      /* Styles for emotion trends */
      .trends-summary {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 4px;
        margin-top: 10px;
      }
      .trends-summary h3 {
        margin-top: 15px;
        margin-bottom: 10px;
        color: #495057;
      }
      .trends-summary ul {
        list-style-type: none;
        padding-left: 0;
      }
      .trends-summary li {
        padding: 5px 0;
        border-bottom: 1px solid #eee;
      }

      /* Error message style */
      .error-message {
        color: #dc3545;
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
      }

      /* Styles for export buttons */
      .button-link {
        display: inline-block;
        background-color: #007bff;
        color: white;
        padding: 10px 15px;
        border-radius: 4px;
        text-decoration: none;
        margin-right: 10px;
      }
      .button-link:hover {
        background-color: #0069d9;
        text-decoration: none;
      }
      #exportCsvBtn {
        background-color: #17a2b8;
      }
      #exportExcelBtn {
        background-color: #28a745;
      }
      #saveSessionBtn {
        background-color: #6c757d;
      }
      #loadSessionBtn {
        background-color: #6c757d;
      }
      #analyzeTrendsBtn {
        background-color: #6610f2;
      }
    </style>
  </head>
  <body>
    <div class="user-nav">
      <button id="logoutBtn" class="logout-btn">Logout</button>
    </div>
    
    <div class="container">
      <h1>Real-Time Interrogation Analysis</h1>
      
  
      <div class="controls">
        <h2>Controls</h2>
        <button id="startBtn">Start Analysis</button>
        <button id="stopBtn" disabled>Stop Analysis</button>
      </div>

      <div class="status">
        <h2>Status</h2>
        <p>Current Status: <span id="statusText">Idle</span></p>
      </div>

      <!-- New Session Management Section -->
      <div class="session-management">
        <h2>Session Management</h2>
        <div class="button-group">
          <button id="saveSessionBtn" disabled>Save Current Session</button>
          <button id="loadSessionBtn">Load Session</button>
        </div>
        <div id="sessionsList" class="sessions-list">
          <p><i>No saved sessions available</i></p>
        </div>
      </div>
      <!-- End Session Management Section -->

      <div class="results">
        <h2>Live Analysis</h2>
        <p>Dominant Emotion: <span id="dominantEmotion">N/A</span></p>
        <div class="chart-container">
          <canvas id="emotionChart"></canvas>
        </div>
        <h3>Raw Data Stream (Last 5 Events):</h3>
        <pre id="rawDataStream">Waiting for data...</pre>
        <!-- Optional: Video Feed Display -->
        <!-- Uncomment the line below if you uncomment the video_feed route in app.py -->
        <!-- <h2>Live Video Feed</h2> -->
        <!-- <img id="videoFeed" src="" alt="Video Feed (Starts when analysis begins)"> -->
      </div>

      <!-- New section for Behavioral Analysis -->
      <div class="results" id="behavioralAnalysisSection">
        <h2>Behavioral Analysis</h2>
        <div id="behaviorAnalysisText">
          <p>
            <i>Analysis will appear here periodically when processing...</i>
          </p>
        </div>
      </div>
      <!-- End New Section -->

      <!-- New Emotion Trends Section -->
      <div class="results" id="emotionTrendsSection">
        <h2>Emotion Trends Analysis</h2>
        <div id="emotionTrendsContent">
          <p><i>Click the button below to analyze emotion trends</i></p>
        </div>
        <button id="analyzeTrendsBtn" disabled>Analyze Emotion Trends</button>
      </div>
      <!-- End Emotion Trends Section -->

      <div class="report">
        <h2>Report & Export</h2>
        <p>
          Once analysis is stopped, you can download the full report or export
          data.
        </p>
        <div class="button-group">
          <a
            id="downloadLink"
            href="/download_report"
            download
            class="button-link"
            >Download Full Report (TXT)</a
          >
          <button id="exportCsvBtn" disabled>Export to CSV</button>
          <button id="exportExcelBtn" disabled>Export to Excel</button>
        </div>
      </div>
    </div>

    <script>
      console.log("Script loaded."); // Check if script runs at all
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const statusText = document.getElementById("statusText");
      const dominantEmotionSpan = document.getElementById("dominantEmotion");
      const rawDataStreamPre = document.getElementById("rawDataStream");
      // const videoFeedImg = document.getElementById('videoFeed'); // Uncomment if using video feed
      const downloadLink = document.getElementById("downloadLink");
      // Get the new element for behavioral analysis text
      const behaviorAnalysisDiv = document.getElementById(
        "behaviorAnalysisText"
      );

      // New UI elements
      const saveSessionBtn = document.getElementById("saveSessionBtn");
      const loadSessionBtn = document.getElementById("loadSessionBtn");
      const sessionsList = document.getElementById("sessionsList");
      const analyzeTrendsBtn = document.getElementById("analyzeTrendsBtn");
      const emotionTrendsContent = document.getElementById(
        "emotionTrendsContent"
      );
      const exportCsvBtn = document.getElementById("exportCsvBtn");
      const exportExcelBtn = document.getElementById("exportExcelBtn");

      let eventSource = null;
      let emotionChart = null;
      let rawDataBuffer = [];
      const MAX_BUFFER_SIZE = 5; // Keep last 5 raw events displayed
      const emotionLabels = [
        "angry",
        "disgust",
        "fear",
        "happy",
        "sad",
        "surprise",
        "neutral",
      ]; // Ensure this matches DeepFace output
      const MAX_ANALYSIS_HISTORY = 5; // How many analysis texts to keep visible
      let behaviorAnalysisBuffer = []; // Buffer to store analysis texts
      let emotionData = []; // Add this global variable declaration at the top with other globals

      console.log("Elements selected:", {
        startBtn,
        stopBtn,
        statusText,
        dominantEmotionSpan,
        rawDataStreamPre,
        behaviorAnalysisDiv,
        saveSessionBtn,
        loadSessionBtn,
        sessionsList,
        analyzeTrendsBtn,
        emotionTrendsContent,
        exportCsvBtn,
        exportExcelBtn,
      });

      // Function to initialize or update the chart
      function setupChart() {
        console.log("Setting up chart...");
        try {
          const ctx = document.getElementById("emotionChart").getContext("2d");
          if (!ctx) {
            console.error("Failed to get 2D context for chart canvas!");
            return;
          }
          emotionChart = new Chart(ctx, {
            type: "bar",
            data: {
              labels: emotionLabels,
              datasets: [
                {
                  label: "Emotion Score (%)",
                  data: Array(emotionLabels.length).fill(0), // Initialize with zeros
                  backgroundColor: "rgba(54, 162, 235, 0.6)",
                  borderColor: "rgba(54, 162, 235, 1)",
                  borderWidth: 1,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  max: 100, // Emotions are percentages
                },
              },
              plugins: {
                legend: {
                  display: false,
                },
                title: {
                  display: true,
                  text: "Real-Time Emotion Distribution",
                },
              },
            },
          });
          console.log("Chart setup complete.");
        } catch (error) {
          console.error("Error during chart setup:", error);
        }
      }

      // Function to update the chart data
      function updateChart(emotions) {
        if (!emotionChart) {
          console.warn("updateChart called but chart is not initialized.");
          return;
        }
        console.log("Updating chart with data:", emotions);
        try {
          const dataValues = emotionLabels.map((label) => emotions[label] || 0);
          emotionChart.data.datasets[0].data = dataValues;
          emotionChart.update(); // Redraw the chart
          console.log("Chart update successful.");
        } catch (error) {
          console.error("Error updating chart:", error);
        }
      }

      // Function to update the raw data display
      function updateRawDataDisplay(newData) {
        console.log("Updating raw data display:", newData);
        try {
          rawDataBuffer.push(JSON.stringify(newData, null, 2)); // Add new data formatted
          if (rawDataBuffer.length > MAX_BUFFER_SIZE) {
            rawDataBuffer.shift(); // Remove the oldest entry
          }
          rawDataStreamPre.textContent = rawDataBuffer.join("\n---\n"); // Display buffer entries separated
        } catch (error) {
          console.error("Error updating raw data display:", error);
        }
      }

      // Function to update the behavioral analysis display
      function updateBehaviorAnalysisDisplay(analysisText) {
        console.log("Updating behavior analysis display:", analysisText);
        try {
          const timestamp = new Date().toLocaleTimeString();
          const newAnalysisEntry = `<p><strong>[${timestamp}]</strong> ${analysisText}</p>`;

          // Add to buffer and limit size
          behaviorAnalysisBuffer.unshift(newAnalysisEntry); // Add to the beginning
          if (behaviorAnalysisBuffer.length > MAX_ANALYSIS_HISTORY) {
            behaviorAnalysisBuffer.pop(); // Remove the oldest
          }

          // Update the display
          behaviorAnalysisDiv.innerHTML = behaviorAnalysisBuffer.join(""); // Join entries
        } catch (error) {
          console.error("Error updating behavior analysis display:", error);
        }
      }

      // Function to load saved sessions
      function loadSavedSessions() {
        console.log("Loading saved sessions...");
        fetch("/list_sessions")
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`
              );
            }
            return response.json();
          })
          .then((sessions) => {
            console.log("Saved sessions:", sessions);
            if (sessions.length === 0) {
              sessionsList.innerHTML =
                "<p><i>No saved sessions available</i></p>";
              return;
            }

            const sessionsListHTML = sessions
              .map((session) => {
                const modifiedDate = new Date(
                  session.modified
                ).toLocaleString();
                const sizeKB = (session.size / 1024).toFixed(2);
                return `
                <div class="session-item">
                  <div class="session-info">
                    <span class="session-name">${session.filename}</span>
                    <span class="session-meta">Modified: ${modifiedDate} | Size: ${sizeKB} KB</span>
                  </div>
                  <button class="load-session-btn" data-filename="${session.filename}">Load</button>
                </div>
              `;
              })
              .join("");

            sessionsList.innerHTML = sessionsListHTML;

            // Add event listeners to load buttons
            document.querySelectorAll(".load-session-btn").forEach((btn) => {
              btn.addEventListener("click", function () {
                const filename = this.getAttribute("data-filename");
                loadSession(filename);
              });
            });
          })
          .catch((error) => {
            console.error("Error loading sessions:", error);
            sessionsList.innerHTML = `<p class="error-message">Error loading sessions: ${error.message}</p>`;
          });
      }

      // Function to load a specific session
      function loadSession(filename) {
        console.log("Loading session:", filename);
        fetch("/load_session", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ filename: filename }),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`
              );
            }
            return response.json();
          })
          .then((data) => {
            console.log("Session loaded:", data);
            if (data.status === "success") {
              // Update UI with loaded data
              updateUIWithLoadedSession(data.data);
            } else {
              alert(
                "Error loading session: " + (data.error || "Unknown error")
              );
            }
          })
          .catch((error) => {
            console.error("Error loading session:", error);
            alert("Error loading session: " + error.message);
          });
      }

      // Function to update UI with loaded session data
      function updateUIWithLoadedSession(sessionData) {
        try {
          console.log("Updating UI with session data:", sessionData);

          // Clear existing data
          emotionData = [];
          behaviorAnalysisBuffer = [];
          rawDataBuffer = [];

          // Update emotion data
          if (sessionData.emotion_log && sessionData.emotion_log.length > 0) {
            emotionData = sessionData.emotion_log;

            // Update the chart with the last entry's emotions
            const lastEntry = emotionData[emotionData.length - 1];
            if (lastEntry && lastEntry.emotions) {
              updateChart(lastEntry.emotions);
            }

            // Update the raw data stream display with last 5 entries
            const lastFiveEvents = emotionData.slice(-5);
            rawDataBuffer = lastFiveEvents.map(
              (entry) =>
                `${entry.timestamp}: ${
                  entry.dominant_emotion
                } (${Object.entries(entry.emotions)
                  .map(([emotion, value]) => `${emotion}: ${value.toFixed(2)}%`)
                  .join(", ")})`
            );
            document.getElementById("rawDataStream").textContent =
              rawDataBuffer.join("\n");

            // Update dominant emotion display
            document.getElementById("dominantEmotion").textContent =
              lastEntry.dominant_emotion;
          }

          // Update behavioral analysis
          if (
            sessionData.behavioral_analyses &&
            sessionData.behavioral_analyses.length > 0
          ) {
            behaviorAnalysisBuffer = sessionData.behavioral_analyses
              .slice(-MAX_ANALYSIS_HISTORY)
              .map(
                (entry) =>
                  `<p><strong>${new Date(
                    entry.timestamp
                  ).toLocaleString()}:</strong> ${entry.analysis}</p>`
              );
            document.getElementById("behaviorAnalysisText").innerHTML =
              behaviorAnalysisBuffer.join("");
          } else {
            document.getElementById("behaviorAnalysisText").innerHTML =
              "<p><i>No behavioral analysis data available</i></p>";
          }

          // Enable/disable buttons based on data availability
          const hasData = emotionData.length > 0;
          document.getElementById("analyzeTrendsBtn").disabled = !hasData;
          document.getElementById("exportCsvBtn").disabled = !hasData;
          document.getElementById("exportExcelBtn").disabled = !hasData;
          document.getElementById("saveSessionBtn").disabled = !hasData;

          // Update status text
          statusText.textContent = "Session Loaded";

          // Update emotion trends if we have data
          if (hasData) {
            analyzeEmotionTrends();
          }

          alert("Session loaded successfully!");
        } catch (error) {
          console.error("Error updating UI with loaded session:", error);
          alert("Error loading session data: " + error.message);
        }
      }

      // Function to save current session
      function saveCurrentSession() {
        console.log("Saving current session...");
        fetch("/save_session", { method: "POST" })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`
              );
            }
            return response.json();
          })
          .then((data) => {
            console.log("Session saved:", data);
            if (data.status === "success") {
              alert("Session saved successfully!");
              loadSavedSessions(); // Refresh the sessions list
            } else {
              alert("Error saving session: " + (data.error || "Unknown error"));
            }
          })
          .catch((error) => {
            console.error("Error saving session:", error);
            alert("Error saving session: " + error.message);
          });
      }

      // Function to export data to CSV
      function exportToCSV() {
        console.log("Exporting to CSV...");
        fetch("/export_csv")
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`
              );
            }
            return response.json();
          })
          .then((data) => {
            console.log("CSV exported:", data);
            if (data.status === "success") {
              alert("Data exported to CSV successfully!");
            } else {
              alert(
                "Error exporting to CSV: " + (data.error || "Unknown error")
              );
            }
          })
          .catch((error) => {
            console.error("Error exporting to CSV:", error);
            alert("Error exporting to CSV: " + error.message);
          });
      }

      // Function to export data to Excel
      function exportToExcel() {
        console.log("Exporting to Excel...");
        fetch("/export_excel")
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`
              );
            }
            return response.json();
          })
          .then((data) => {
            console.log("Excel exported:", data);
            if (data.status === "success") {
              alert("Data exported to Excel successfully!");
            } else {
              alert(
                "Error exporting to Excel: " + (data.error || "Unknown error")
              );
            }
          })
          .catch((error) => {
            console.error("Error exporting to Excel:", error);
            alert("Error exporting to Excel: " + error.message);
          });
      }

      // Function to analyze emotion trends
      function analyzeEmotionTrends() {
        console.log("Analyzing emotion trends...");
        fetch("/get_emotion_trends")
          .then((response) => {
            // Check if response is OK
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`
              );
            }

            // Check content type to ensure we're getting JSON
            const contentType = response.headers.get("content-type");
            if (!contentType || !contentType.includes("application/json")) {
              throw new Error(
                `Expected JSON but got ${contentType || "unknown content type"}`
              );
            }

            return response.json();
          })
          .then((data) => {
            console.log("Emotion trends:", data);
            if (data.status === "success" && data.trends) {
              displayEmotionTrends(data.trends);
            } else {
              emotionTrendsContent.innerHTML = `<p class="error-message">Error: ${
                data.error || "Unknown error"
              }</p>`;
            }
          })
          .catch((error) => {
            console.error("Error analyzing trends:", error);
            emotionTrendsContent.innerHTML = `<p class="error-message">Error analyzing trends: ${error.message}</p>`;
          });
      }

      // Function to display emotion trends
      function displayEmotionTrends(trends) {
        if (!trends) {
          emotionTrendsContent.innerHTML =
            "<p><i>No trend data available</i></p>";
          return;
        }

        let trendsHTML = "<div class='trends-summary'>";

        // Session info
        trendsHTML += "<h3>Session Summary</h3>";
        trendsHTML += `<p>Total Emotions: ${trends.total_emotions}</p>`;
        trendsHTML += `<p>Unique Emotions: ${trends.unique_emotions}</p>`;
        trendsHTML += `<p>Emotion Changes: ${trends.emotion_changes}</p>`;
        trendsHTML += `<p>Most Common Emotion: ${trends.most_common_emotion}</p>`;

        // Emotion distribution
        trendsHTML += "<h3>Emotion Distribution</h3>";
        trendsHTML += "<ul>";
        for (const [emotion, count] of Object.entries(
          trends.emotion_distribution
        )) {
          const percentage = ((count / trends.total_emotions) * 100).toFixed(1);
          trendsHTML += `<li>${emotion}: ${count} (${percentage}%)</li>`;
        }
        trendsHTML += "</ul>";

        // Time-based stats
        trendsHTML += "<h3>Time-Based Statistics</h3>";
        trendsHTML += `<p>Emotions per Minute: ${trends.time_based_stats.emotions_per_minute.toFixed(
          2
        )}</p>`;
        trendsHTML += `<p>Average Emotion Duration: ${trends.time_based_stats.average_emotion_duration.toFixed(
          2
        )} seconds</p>`;

        // Confidence
        if (trends.average_confidence !== null) {
          trendsHTML += `<p>Average Confidence: ${trends.average_confidence.toFixed(
            2
          )}%</p>`;
        }

        trendsHTML += "</div>";

        emotionTrendsContent.innerHTML = trendsHTML;
      }

      startBtn.addEventListener("click", async () => {
        console.log("Start button clicked.");
        statusText.textContent = "Starting...";
        startBtn.disabled = true;
        stopBtn.disabled = true;
        behaviorAnalysisDiv.innerHTML = ""; // Clear previous analysis
        behaviorAnalysisBuffer = []; // Clear buffer
        saveSessionBtn.disabled = true; // Disable save until we have data
        analyzeTrendsBtn.disabled = true; // Disable trends analysis until we have data
        exportCsvBtn.disabled = true; // Disable export until we have data
        exportExcelBtn.disabled = true; // Disable export until we have data

        try {
          console.log("Sending POST request to /start_analysis");
          const response = await fetch("/start_analysis", { method: "POST" });
          console.log(
            "Response received from /start_analysis, status:",
            response.status
          );

          if (response.ok) {
            statusText.textContent = "Processing";
            stopBtn.disabled = false;
            dominantEmotionSpan.textContent = "Waiting for face...";
            behaviorAnalysisDiv.innerHTML =
              "<p><i>Waiting for first behavioral analysis...</i></p>";
            rawDataBuffer = []; // Clear buffer

            console.log(
              "Analysis started successfully. Setting up chart and EventSource."
            );
            if (!emotionChart) {
              // Initialize chart if not already done
              setupChart();
            } else {
              // Reset chart data
              console.log("Resetting existing chart data.");
              updateChart(
                Object.fromEntries(emotionLabels.map((label) => [label, 0]))
              );
            }

            // Start listening to SSE
            console.log("Creating new EventSource for /analysis_stream");
            eventSource = new EventSource("/analysis_stream");

            eventSource.onopen = function () {
              console.log("EventSource connection opened.");
            };

            eventSource.onmessage = function (event) {
              console.log("SSE message received:", event.data);
              try {
                const messageData = JSON.parse(event.data);
                // console.log("Parsed SSE data:", messageData);

                // Check message type
                if (messageData.type === "emotion_update") {
                  const emotionPayload = messageData.payload;
                  dominantEmotionSpan.textContent =
                    emotionPayload.dominant_emotion || "N/A";
                  if (emotionPayload.emotions) {
                    updateChart(emotionPayload.emotions);
                  }

                  // Enable save and export buttons once we have data
                  saveSessionBtn.disabled = false;
                  exportCsvBtn.disabled = false;
                  exportExcelBtn.disabled = false;
                  analyzeTrendsBtn.disabled = false;
                } else if (messageData.type === "behavior_analysis") {
                  const analysisPayload = messageData.payload;
                  updateBehaviorAnalysisDisplay(analysisPayload);
                } else {
                  console.warn(
                    "Unknown SSE message type received:",
                    messageData.type
                  );
                }

                updateRawDataDisplay(messageData);
              } catch (e) {
                console.error(
                  "Error parsing SSE data or updating UI:",
                  e,
                  "Raw data:",
                  event.data
                );
                dominantEmotionSpan.textContent = "Error parsing data";
              }
            };

            eventSource.onerror = function (error) {
              console.error("EventSource failed:", error);
              statusText.textContent = "Stream Error";
              dominantEmotionSpan.textContent = "Error";
              behaviorAnalysisDiv.innerHTML =
                "<p><i>Error connecting to analysis stream.</i></p>";
              stopBtn.disabled = false; // Allow user to try stopping
              startBtn.disabled = false;
              if (eventSource) {
                eventSource.close();
                console.log("Closed EventSource due to error.");
                eventSource = null;
              }
            };

            // // Optional: Start video feed
            // if (videoFeedImg) {
            //     videoFeedImg.src = '/video_feed?t=' + new Date().getTime(); // Add timestamp to avoid caching
            //     videoFeedImg.style.display = 'block';
            // }
          } else {
            const errorData = await response.json();
            console.error(
              "Failed to start analysis:",
              response.status,
              errorData
            );
            statusText.textContent = `Error: ${
              errorData.status || response.statusText
            }`;
            startBtn.disabled = false; // Re-enable start on failure
          }
        } catch (error) {
          console.error("Error in Start button handler:", error);
          statusText.textContent = "Failed to start (client-side error)";
          startBtn.disabled = false;
        }
      });

      stopBtn.addEventListener("click", async () => {
        console.log("Stop button clicked.");
        statusText.textContent = "Stopping...";
        stopBtn.disabled = true;

        // Stop listening to SSE
        if (eventSource) {
          eventSource.close();
          eventSource = null;
          console.log("SSE connection closed by Stop button.");
        }

        // // Optional: Stop video feed
        // if (videoFeedImg) {
        //      videoFeedImg.src = ""; // Clear the src to stop the stream
        //      videoFeedImg.style.display = 'none';
        // }

        try {
          console.log("Sending POST request to /stop_analysis");
          const response = await fetch("/stop_analysis", { method: "POST" });
          console.log(
            "Response received from /stop_analysis, status:",
            response.status
          );
          if (response.ok) {
            statusText.textContent = "Stopped";
            dominantEmotionSpan.textContent = "N/A"; // Reset display
            rawDataStreamPre.textContent = "Analysis stopped.";
            // Optionally clear chart or leave last state
            // console.log("Resetting chart after stop.");
            // updateChart(Object.fromEntries(emotionLabels.map(label => [label, 0])));
          } else {
            const errorData = await response.json();
            console.error(
              "Failed to stop analysis:",
              response.status,
              errorData
            );
            statusText.textContent = `Error stopping: ${
              errorData.status || response.statusText
            }`;
          }
        } catch (error) {
          console.error("Error in Stop button handler:", error);
          statusText.textContent = "Failed to stop (client-side error)";
        } finally {
          startBtn.disabled = false; // Always re-enable start after stop attempt
        }
      });

      // Add event listeners for new buttons
      saveSessionBtn.addEventListener("click", saveCurrentSession);
      loadSessionBtn.addEventListener("click", loadSavedSessions);
      analyzeTrendsBtn.addEventListener("click", analyzeEmotionTrends);
      exportCsvBtn.addEventListener("click", exportToCSV);
      exportExcelBtn.addEventListener("click", exportToExcel);

      // Initialize chart on page load
      document.addEventListener("DOMContentLoaded", (event) => {
        console.log("DOM fully loaded and parsed.");
        setupChart();
        loadSavedSessions(); // Load saved sessions on page load
      });
    </script>
  </body>
</html>
